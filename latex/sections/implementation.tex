\section{Implementation}
\label{sec:implementation}

The proposed approach is implemented in a prototype existing as an extension of the Papyrus modeler \cite{cea-list_papyrus_????}. Each SM is created by using a SM diagram and contained in a component. Low-level processing of SM actions is directly embedded by a block of code written specific programming languages such as \tb{C++/JAVA} in the SM. \tb{C++} code is generated by the prototype but other object-oriented languages can be easily generated since the approach relies on existing code generators from the intermediate model. The code generation consists of transforming the SM to UML classes and eventually to code by a code generator following the proposed approach. The code generator can generate code for hierarchical and concurrent SMs. In the reverse direction, code pattern detection is implemented as described in the previous section to verify SM semantics in code. If the generated code is modified, two options are supported by the prototype interface to make the SM and code consistent again. One is to create a new SM from the modified code in the same Eclipse project and the other one is to update the original SM by providing as input the intermediate model and the SM in a dialog. At the writing moment, the prototype does not support for the reverse of concurrent SMs and pseudo states which are \ti{history}, \ti{join}, \ti{fork},\ti{choice}, and \ti{junction}.