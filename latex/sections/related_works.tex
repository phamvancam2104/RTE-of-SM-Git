\section{Related Work}
\label{sec:related_works}
Two main topics directly related to our study are identified. One is the implementation techniques and code generation for UML SMs and the other one is RTRIP.
\subsection{Implementation and code generation for UML SMs}
Main approaches including switch/if, state table and state pattern are investigated.

Switch/if is the most intuitive technique implementing a "flat" state machine. Two types of switch/if are supported. The first one uses a scalar variable representing the current active state \cite{Booch1998}. A method for each event processes the variable as a discriminator in switch/if statement. The second one uses doubly nested switch/if and has two variables to represent the current active state and the event to be processed \cite{Douglass1999}. The latter are used as the discriminators of an outer switch statement to select between states and an inner one/if statement to decide how the event should be processed. The behavior code of the two types is put in one file or class. This practice makes code cumbersome, complex, difficult to read and less explicit when the number of states grows or the state machine is hierarchical. Furthermore, the first approach lets the code scatter in different places. Therefore, maintaining or modifying such code of complex systems is very difficult.

In \cite{Douglass1999, Duby2001} the authors also propose a double dimensional state table in which one dimension represents states and the other one all possible events. Each cell of the table is associated with a function pointer meaning that the state associated with a dimension index of the cell is triggered by the event associated with the other dimension. This technique is efficient for flat and simple state machines. As the switch/if technique, this approach gets cumbersome and non-trivial to maintain since states and events represented by indexes of the table are not explicit. Furthermore, this approach requires every transition must be triggered by at least an event. This is obviously only applied to a very small sub-set of UML state machines.  
  
State pattern \cite{Allegrini2002,Shalyto2006,Douglass1999} is an object-oriented way to implement state machines. Each state is represented as a class and each event as a method. The event processing is executed by a delegation from the state machine context class to sub-states. Separation of states in classes makes the code more readable and maintainable. Unfortunately, this technique only supports flat state machines. The authors in \cite{niaz_mapping_2004} extends this to overcome its limitations. However, the maintenance of the code generated or implemented by this approach is not trivial since it requires a lot of code to write and many small changes in different places. This is critically impractical when dealing with large state machines. Furthermore, similar to the state table, this approach also poses the requirement of having at least one event for transition.

Double-dispatch pattern is proposed in \cite{spinke_object-oriented_2013} as a new technique to implement state machines. States and events are represented as classes. Our generation approach relies on this approach. The latter provides some 1-1 mappings from state machines to object-oriented code and the implementation technique is not dependent on a specific programming language. However, the approach does not deal with triggerless transitions and different event types supported by UML such as \ti{CallEvent}, \ti{TimeEvent} and \ti{SignalEvent}. Furthermore, the proposed approach is not a code generation approach but manual implementation.

Readers of this paper are recommended referring to c\cite{Domnguez2012} for a systematic survey on different approaches generating code from state machine/state charts.

\subsection{Round-trip engineering}
RTRIP of UML models and object-oriented code are supported in many tools including research prototypes and commercial such as Enterprise Architect \cite{sparxsystems_enterprise_2014}, Visual Paradigm \cite{visual}, AndroMDA \cite{_andromda_}. Although these tools work well with UML class diagrams and code, behavioral diagrams are not well supported.  

Fujaba \cite{KNNZ99_2_ag} offers a round-trip engineering environment. An interesting part of Fujaba is that it abstracts from Java source code to UML class diagrams and a so-called story-diagrams. Java code can also be generated from these diagrams. RTRIP of these diagrams and code works but limited to the naming conventions and implementation concepts of Fujaba which are not UML-compliant. 

The authors in \cite{angyal_synchronizing_2008} propose a syntactic synchronization technique for domain-specific modeling languages (DSML) and code. The approach uses an Abstract Syntax Tree (AST) metal-model to model source. Changes in code detected by using an algorithm proposed  in \cite{Chawathe:1996:CDH:235968.233366} to compare the AST instance of the current code with the last synchronized one are merged to the instance of DSML. However, an AST is very low level and it is not clear to have mappings from DSML instances to AST instances. Furthermore, although there is an example for illustrating the technique, a systematic evaluation of the approach is not presented to show its scalability.

%Round-trip engineering of Activity diagram and code is proposed in [13]. The approach uses intermediate models to reduce the abstraction gap between diagrams and code. However, the activity diagram contains plenty of low level information such as variable declarations. Furthermore, no semantic analysis is supported.

